import ffmpeg from 'fluent-ffmpeg';
import path from 'path';

const getVideoThumbnail = (
  videoUrl: string,
): Promise<{thumbnails: string[]; gif: string}> => {
  return new Promise((resolve, reject) => {
    const filenames: string[] = []; // Array to hold the filenames
    const gifFilename =
      './uploads/' +
      path.basename(videoUrl, path.extname(videoUrl)) +
      '-animation.webp'; // Change extension to .webp

    ffmpeg()
      .input(videoUrl)
      .screenshots({
        count: 5, // Number of thumbnails to generate
        filename: './uploads/%b-thumb-%i.png', // Filename pattern with index
        size: '640x?', // Set the size of the thumbnails
      })
      .on('end', () => {
        // Generate GIF directly from the video
        ffmpeg()
          .input(videoUrl)
          .outputOptions([
            '-vf',
            'setpts=PTS/(duration/5),fps=5,scale=480:-1:flags=lanczos',
            '-vcodec',
            'libwebp',
            '-lossless',
            '0',
            '-compression_level',
            '6',
            '-q:v',
            '50',
            '-loop',
            '0',
            '-preset',
            'picture',
            '-an',
            '-vsync',
            '0',
            '-f',
            'webp',
          ])
          .output(gifFilename)
          .on('end', () => {
            resolve({thumbnails: filenames, gif: gifFilename}); // Resolve with filenames and GIF
          })
          .on('error', (error) => {
            console.error('ffmpeg', error);
            reject(error); // Reject the promise if an error occurs
          })
          .run();
      })
      .on('error', (error) => {
        console.error('ffmpeg', error);
        reject(error); // Reject the promise if an error occurs
      })
      .on('filenames', (generatedFilenames) => {
        // Capture the filenames generated by ffmpeg
        filenames.push(...generatedFilenames);
      })
      .run();
  });
};

export default getVideoThumbnail;
